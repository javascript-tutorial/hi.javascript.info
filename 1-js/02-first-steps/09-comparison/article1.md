# तुलना

हम गणित से कई तुलना ऑपरेटरों को जानते हैं।

जावास्क्रिप्ट में वे इस तरह लिखे जाते हैं:

- ग्रेटर / से कम: <code>a &gt; b</code>, <code>a &lt; b</code>।
- ग्रेटर / से कम या बराबर: <code>a &gt;= b</code>, <code>a &lt;= b</code>।
- समतुल्य: `a == b`, कृपया दोहरे समानता चिन्ह पर ध्यान दें `==` का अर्थ है समानता परीक्षण, जबकि एकल `a = b` का अर्थ है असाइनमेंट।
- नहीं के बराबर है। गणित में अंकन<code>&ne;</code>है, लेकिन जावास्क्रिप्ट में इसे<code>a != b</code> लिखा जाता है।

इस लेख में हम विभिन्न प्रकार की तुलनाओं के बारे में अधिक जानेंगे, कि कैसे जावास्क्रिप्ट उन्हें महत्वपूर्ण विशिष्टता सहित बनाता है।
अंत में आपको "जावास्क्रिप्ट क्विर्क" से संबंधित मुद्दों से बचने के लिए एक अच्छा नुस्खा मिलेगा।

# बुलियन परिणाम है
सभी तुलना ऑपरेटर एक बूलियन मान लौटाते हैं:

- सत्य - का अर्थ है "हाँ", "सही" या "सत्य"।
- असत्य - का अर्थ "नहीं", "गलत" या "सत्य नहीं" है।

उदाहरण के लिए:
``` js run
alert( 2 > 1 ); // सच (सही)
alert( 2 == 1 ); // गलत (गलत)
alert( 2 != 1 ); // सच (सही)
```

एक तुलना परिणाम एक चर को सौंपा जा सकता है, किसी भी मूल्य की तरह:
``` js run
let result = 5 > 4; // तुलना का परिणाम बताएं
alert( result ); // सच
```

# स्ट्रिंग तुलना
यह देखने के लिए कि क्या एक स्ट्रिंग दूसरे से बड़ी है, जावास्क्रिप्ट तथाकथित "शब्दकोश" या "लेक्सिकोग्राफिक" आदेश का उपयोग करता है।

दूसरे शब्दों में, स्ट्रिंग की तुलना अक्षर-दर-अक्षर की जाती है।

उदाहरण के लिए:
``` js run
alert( 'Z' > 'A' ); // सच
alert( 'Glow' > 'Glee' ); // सच
alert( 'Bee' > 'Be' ); // सच
```

दो स्ट्रिंग की तुलना करने के लिए एल्गोरिथ्म सरल है:

1. दोनों स्ट्रिंगों के पहले चरित्र की तुलना करें।
2. यदि पहली स्ट्रिंग से पहला वर्ण दूसरे स्ट्रिंग की तुलना में अधिक (या कम) है, तो पहली स्ट्रिंग दूसरी की तुलना में अधिक (या कम) है। हमारा काम हो गया।
3. अन्यथा, यदि दोनों तारों के पहले चरित्र समान हैं, तो दूसरे वर्णों की तुलना उसी तरह करें।
4. स्ट्रिंग के अंत तक यही दोहराएं।
5. यदि दोनों स्ट्रिंग एक ही लंबाई में समाप्त होते हैं, तो वे समान हैं। अन्यथायही , लंबी स्ट्रिंग अधिक होती है।

ऊपर दिए गए उदाहरणों में, `'Z'> 'A'` की तुलना पहले चरण में होती है जबकि `"Glow"` और `"Glee"` वर्ण-दर-वर्ण की तुलना की जाती है:

1. `G`, `G` के समान है।
2. `l`, `l` के समान है।
3. `o`, `e` से बड़ा है। यहाँ रुको। पहली स्ट्रिंग अधिक होती है।

```smart header="Not a real dictionary, but Unicode order"
ऊपर दिए गए तुलना एल्गोरिथ्म लगभग शब्दकोशों या फोन पुस्तकों में उपयोग किए जाने वाले के बराबर है, लेकिन यह बिल्कुल समान नहीं है।

मसलन, मामला मायने रखता है। एक कैपिटल लेटर `'A'` लोअरकेस `'a' 'के बराबर नहीं है। कौन सा अधिक है? लोअरकेस `'a'`। क्यों? क्योंकि आंतरिक एन्कोडिंग तालिका जावास्क्रिप्ट उपयोग (यूनिकोड) में लोअरकेस वर्ण का एक बड़ा सूचकांक है। हम अध्याय <info: string> में इसके विशिष्ट विवरण और परिणाम प्राप्त करेंगे।
```

# विभिन्न प्रकारों की तुलना
विभिन्न प्रकारों के मूल्यों की तुलना करते समय, जावास्क्रिप्ट मानों को संख्याओं में परिवर्तित करता है।
उदाहरण के लिए:
``` js run
alert( '2' > 1 ); // सच, स्ट्रिंग '2' नंबर 2 बन जाता है
alert('01' == 1); // सच, स्ट्रिंग '01' नंबर 1 बन जाता है
```
बूलियन मूल्यों के लिए, सत्य 1 हो जाता है और असत्य 0 हो जाता है।

उदाहरण के लिए:
``` js run
alert ( true == 1 ); // सच
alert ( false == 0 ); // सच
```

````smart header="A funny consequence"
यह संभव है, कि एक ही समय में:

- दो मूल्य समान हैं।
- उनमें से एक `सच` एक बूलियन के रूप में है और दूसरा एक `गलत` बूलियन के रूप में है।

उदाहरण के लिए:

```js run
let a = 0;
alert( Boolean(a) ); // असत्य

let b = "0";
alert( Boolean(a) ); // सच

alert(a == b); // सच!
```

जावास्क्रिप्ट के दृष्टिकोण से, यह परिणाम काफी सामान्य है। एक समानता जांच संख्यात्मक रूपांतरण का उपयोग करके मूल्यों को परिवर्तित करता है (इसलिए `"0"`, `0` बन जाता है), जबकि स्पष्ट `बुलियन` रूपांतरण नियमों के एक और सेट का उपयोग करता है।
````

# सख्त समानता

एक नियमित समानता की जांच `==`में एक समस्या है। यह `0` को गलत से अलग नहीं कर सकता:
```js run
alert( 0 == false ); // सच
```
खाली स्ट्रिंग के साथ भी यही होता है:
``` js run
alert('' == false); // सच
```
ऐसा इसलिए होता है क्योंकि विभिन्न प्रकार के ऑपरेंड को समानता ऑपरेटर == द्वारा संख्याओं में परिवर्तित किया जाता है। खाली स्ट्रिंग, झूठ की तरह, एक शून्य बन जाती है।

अगर हम असत्य से `0` को अलग करना चाहते हैं तो क्या करें?

**एक सख्त समानता ऑपरेटर `===` बिना रूपांतरण के समानता की जांच करता है।**

दूसरे शब्दों में, यदि `a` और `b` अलग-अलग प्रकार के हैं, तो `a === b` तुरंत उन्हें बदलने के प्रयास के बिना झूठा लौट आता है।

चलो यह कोशिश करते हैं:
```js run
alert( 0 === false); // असत्य, क्योंकि प्रकार भिन्न हैं
```

एक "सख्त गैर-समानता" ऑपरेटर भी है `!==` के अनुरूप है `! =`।

सख्त समानता ऑपरेटर लिखने के लिए थोड़ा लंबा है, लेकिन यह स्पष्ट करता है कि क्या चल रहा है और त्रुटियों के लिए कम जगह छोड़ता है।

# नल और  ुन्डेफिनेड के साथ तुलना
अन्य मानों की तुलना में नल या  ुन्डेफिनेड होने पर एक गैर-सहज व्यवहार होता है।

सख्त समानता की जांच के लिए `===`
: ये मूल्य अलग-अलग हैं, क्योंकि उनमें से प्रत्येक एक अलग प्रकार है।

```js run
alert( null === undefined ); // असत्य
```

गैर-सख्त चेक के लिए `==`
: एक विशेष नियम है। ये दोनों एक "स्वीट कपल" हैं: वे एक-दूसरे के बराबर (`==` के अर्थ में) हैं, लेकिन कोई दूसरा मूल्य नहीं।

```js run
alert( null == undefined ); // सच
```

गणित और अन्य तुलनाओं के लिए `<> <=> =`
: नल /  ुन्डेफिनेड संख्या में परिवर्तित हो जाते हैं: `null` 0 हो जाता है, जबकि `undefined` `NaN` हो जाता है।

अब देखते हैं कुछ मजेदार चीजें, जो तब होती हैं, जब हम इन नियमों को लागू करते हैं। और, क्या अधिक महत्वपूर्ण है, कैसे उनके साथ एक जाल में नहीं पड़ना।

# अजीब परिणाम: नल बनाम 0
चलो `null` के साथ `0` की तुलना करें:
```js run
alert( null > 0); // (1) झूठा
alert( null == 0); // (2) झूठा
alert( null >= 0); // (3) *! * सच * /! *
```

गणितीय, यह अजीब है। अंतिम परिणाम में कहा गया है कि "`null` शून्य से अधिक या शून्य के बराबर है", इसलिए ऊपर की तुलनाओं में से एक में यह सच होना चाहिए, लेकिन वे दोनों झूठे हैं।

कारण यह है कि एक समानता जांच `==` और तुलना `> <> = <=` अलग तरीके से काम करते हैं। तुलना शून्य को एक संख्या में बदल देती है, इसे `0` मानते हैं। इसीलिए (3) `null> = 0` सत्य है और (1) `null> 0` मिथ्या है।

दूसरी ओर, `null` और `undefined` के लिए समानता की जांच `==` को ऐसे परिभाषित किया गया है, बिना किसी रूपांतरण के, वे एक-दूसरे के बराबर हैं और किसी अन्य चीज़ के बराबर नहीं हैं। इसीलिए (2) `null == 0` असत्य है।

# एक अतुलनीय  ुन्डेफिनेड
 ुन्डेफिनेड मूल्य को अन्य मूल्यों की तुलना में नहीं किया जाना चाहिए:
```js run
alert( undefined > 0); // झूठा (1)
alert( undefined < 0); // झूठा (2)
alert( undefined == 0); // झूठा (3)
```

यह शून्य को इतना नापसंद क्यों करता है? हमेशा झूठा!

हमें ये परिणाम मिले क्योंकि:

- तुलना (1) और (2) झूठी हो जाती है क्योंकि `undefined` `NaN` में परिवर्तित हो जाता है और `NaN` एक विशेष संख्यात्मक मान होता है जो सभी तुलनाओं के लिए गलत होता है।
- समानता की जांच (3) झूठी होती है क्योंकि `undefined` केवल `null` और `undefined` के बराबर होता है।

# समस्याओं से बचें
हम इन उदाहरणों पर क्यों गए? क्या हमें हर समय इन ख़ासियतों को याद रखना चाहिए? असल में ऐसा नहीं है। दरअसल, ये मुश्किल चीजें धीरे-धीरे समय के साथ परिचित हो जाएंगी, लेकिन उनके साथ समस्याओं से बचने का एक ठोस तरीका है:

- असाधारण देखभाल के साथ सख्त समानता `===` को छोड़कर `undefined/null` के साथ किसी भी तुलना का व्यवहार करें।
- तुलना का उपयोग न करें `> => <<=` एक वेरिएबल के साथ जो `undefined/null` हो सकता है, जब तक कि आप वास्तव में निश्चित नहीं हैं कि आप क्या कर रहे हैं। यदि किसी वेरिएबल में ये मान हो सकते हैं, तो उनके लिए अलग से जाँच करें।

# सारांश
- तुलना ऑपरेटर एक बूलियन मान लौटाते हैं।
- स्ट्रिंग्स की तुलना "शब्दकोश" क्रम में अक्षर-दर-अक्षर से की जाती है।
- जब विभिन्न प्रकारों के मूल्यों की तुलना की जाती है, तो वे संख्याओं में परिवर्तित हो जाते हैं (एक सख्त समानता जांच के बहिष्करण के साथ)।
- मान, `null`और `undefined` समान `==` एक दूसरे के, और किसी भी अन्य मूल्य के बराबर नहीं है।
- वैरिएबल के साथ `>` या `<` जैसे तुलनाओं का उपयोग करते समय सावधान रहें जो कभी-कभी `undefined/null` हो सकते हैं। `undefined/null` के लिए अलग से जाँच करना एक अच्छा विचार है।
