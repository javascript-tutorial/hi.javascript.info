# Function एक्सप्रेशन

Javascript में, एक function "जादुई भाषा संरचना" नहीं है, बल्कि एक विशेष प्रकार का मूल्य है।

हमने पहले जिस सिंटैक्स का उपयोग किया था, उसे *function घोषणा* कहा जाता है:

```js
function sayHi() {
  alert( "Hello" );
}
```

function बनाने के लिए एक और सिंटैक्स है जिसे *function एक्सप्रेशन* कहा जाता है।

यह इस तरह दीखता है:

```js
let sayHi = function() {
  alert( "Hello" );
};
```

यहां, function को किसी अन्य मान की तरह, स्पष्ट रूप से बनाया गया है और variable को असाइन किया गया है। कोई फर्क नहीं पड़ता कि function को कैसे परिभाषित किया गया है, यह केवल 'sayHi' variable में संग्रहीत एक मान है।

इन कोड नमूनों का अर्थ एक ही है: "एक function बनाएं और इसे variable `sayHi` में डालें"।

हम `alert` का उपयोग करके उस मूल्य को प्रिंट भी कर सकते हैं:

```js run
function sayHi() {
  alert( "Hello" );
}

*!*
alert( sayHi ); // shows the function code
*/!*
```

कृपया ध्यान दें कि अंतिम पंक्ति function नहीं चलाती है, क्योंकि `sayHi` के बाद कोई कोष्ठक नहीं है। ऐसी प्रोग्रामिंग भाषाएं हैं जहां किसी function नाम का कोई उल्लेख इसके निष्पादन का कारण बनता है, लेकिन Javascript ऐसा नहीं है।

Javascript में, एक function एक मान है, इसलिए हम इसे एक मान के रूप में व्यवहार कर सकते हैं। उपरोक्त कोड इसका स्ट्रिंग प्रतिनिधित्व दिखाता है, जो स्रोत कोड है।

निश्चित रूप से, एक function  एक विशेष मूल्य है, इस अर्थ में कि हम इसे `sayHi()` की तरह कॉल कर सकते हैं।

लेकिन यह फिर भी एक मूल्य है। इसलिए हम इसके साथ अन्य प्रकार के मूल्यों की तरह काम कर सकते हैं।

हम एक function को दूसरे variable में कॉपी कर सकते हैं:

```js run no-beautify
function sayHi() {   // (1) create
  alert( "Hello" );
}

let func = sayHi;    // (2) copy

func(); // Hello     // (3) run the copy (it works)!
sayHi(); // Hello    //     this still works too (why wouldn't it)
```

ऊपर विस्तार से यह होता है:

1. Function घोषणा `(1)` function बनाता है और इसे `sayHi` नाम के variable में डालता है।
2. लाइन `(2)` इसे variable `func` में कॉपी करती है। कृपया फिर से ध्यान दें: `sayHi` के बाद कोई कोष्ठक नहीं है। अगर वहाँ होता, तो `func = sayHi()` *कॉल का परिणाम* `sayHi()` को `func` में लिखता, न कि *function* `sayHi` को ही।
3. अब function को `sayHi()` और `func()` दोनों के रूप में कॉल किया जा सकता है।

ध्यान दें कि हम पहली पंक्ति में `sayHi` घोषित करने के लिए एक function एक्सप्रेशन का भी इस्तेमाल कर सकते थे:

```js
let sayHi = function() {
  alert( "Hello" );
};

let func = sayHi;
// ...
```

सब कुछ वैसा ही काम करेगा।


````smart header="अंत में अर्धविराम क्यों है?"
आपको आश्चर्य हो सकता है कि function एक्सप्रेशन के अंत में अर्धविराम क्यों होता है, लेकिन function घोषणा में यह नहीं होता है:

```js
function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
}*!*;*/!*
```

उत्तर सीधा है:
- कोड ब्लॉक और सिंटैक्स संरचनाओं के अंत में `;` की कोई आवश्यकता नहीं है जो उनका उपयोग करते हैं जैसे `if {...}`, `के लिए { }`, `फ़ंक्शन f { }` आदि।
- स्टेटमेंट के अंदर एक function एक्सप्रेशन का उपयोग किया जाता है: `let sayHi = ...;`, मान के रूप में। यह एक कोड ब्लॉक नहीं है, बल्कि एक असाइनमेंट है। स्टेटमेंट के अंत में अर्धविराम `;` की सिफारिश की जाती है, भले ही मूल्य कुछ भी हो। तो यहां अर्धविराम function अभिव्यक्ति से संबंधित नहीं है, यह केवल स्टेटमेंट को समाप्त करता है।
````

## कॉलबैक functions

आइए function को मानों के रूप में पास करने और function एक्सप्रेशन का उपयोग करने के अधिक उदाहरण देखें।

हम तीन parameters के साथ `ask(question, yes, no)` function लिखेंगे:

`question`
: प्रश्न का पाठ

`yes`
: यदि उत्तर "हां" है तो function चलेगा

`no`
: यदि उत्तर "नहीं" है तो function चलेगा

Function को `प्रश्न` पूछना चाहिए और, उपयोगकर्ता के उत्तर के आधार पर, `yes()` या `no()` पर कॉल करना चाहिए:

```js run
*!*
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
*/!*

function showOk() {
  alert( "You agreed." );
}

function showCancel() {
  alert( "You canceled the execution." );
}

// usage: functions showOk, showCancel are passed as arguments to ask
ask("Do you agree?", showOk, showCancel);
```

व्यावहारिक रूप से, ऐसे function काफी उपयोगी होते हैं। वास्तविक जीवन `ask` और उपरोक्त उदाहरण के बीच मुख्य अंतर यह है कि वास्तविक जीवन के function एक साधारण `confirm` की तुलना में उपयोगकर्ता के साथ बातचीत करने के लिए अधिक जटिल तरीकों का उपयोग करते हैं। ब्राउज़र में, ऐसा function आमतौर पर एक अच्छी दिखने वाली प्रश्न विंडो बनाता है। लेकिन यह एक दूसरी कहानी है।

**`ask` के तर्क `showOk` और `showCancel` को *कॉलबैक function* या सिर्फ *कॉलबैक* कहा जाता है।**

विचार यह है कि हम एक function पास करते हैं और उम्मीद करते हैं कि यदि आवश्यक हो तो इसे बाद में "कॉलबैक किया जाए"। हमारे मामले में, `showOk` "हां" उत्तर के लिए कॉलबैक बन जाता है, और "नहीं" उत्तर के लिए `showCancel` बन जाता है।

हम एक ही function को बहुत छोटा लिखने के लिए function एक्सप्रेशंस का उपयोग कर सकते हैं:

```js run no-beautify
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

*!*
ask(
  "Do you agree?",
  function() { alert("You agreed."); },
  function() { alert("You canceled the execution."); }
);
*/!*
```

यहां, `ask(...)` कॉल के ठीक अंदर function घोषित किए गए हैं। उनका कोई नाम नहीं है, और इसलिए उन्हें *अनाम* कहा जाता है। इस तरह के function `ask` के बाहर पहुंच योग्य नहीं हैं (क्योंकि वे variable को असाइन नहीं किए गए हैं), लेकिन यह वही है जो हम यहां चाहते हैं।

ऐसा कोड हमारी स्क्रिप्ट में बहुत स्वाभाविक रूप से प्रकट होता है, यह जावास्क्रिप्ट की भावना में है।

```smart header="एक function एक \"क्रिया\" का प्रतिनिधित्व करने वाला मान है"
स्ट्रिंग या संख्या जैसे नियमित मान *डेटा* का प्रतिनिधित्व करते हैं।

एक function को एक *क्रिया* के रूप में माना जा सकता है।

हम इसे variables के बीच पास कर सकते हैं और जब चाहें चला सकते हैं।
```


## Function एक्सप्रेशन बनाम function घोषणा

आइए function घोषणाओं और एक्सप्रेशन के बीच महत्वपूर्ण अंतर तैयार करें।

सबसे पहले, सिंटेक्स: कोड में उनके बीच अंतर कैसे करें।

- *Function घोषणा:* एक फ़ंक्शन, जिसे मुख्य कोड प्रवाह में एक अलग स्टेटमेंट के रूप में घोषित किया गया है।

    ```js
    // Function घोषणा
    function sum(a, b) {
      return a + b;
    }
    ```
- *Function एक्सप्रेशन:* एक function, एक एक्सप्रेशन के अंदर या किसी अन्य सिंटेक्स निर्माण के अंदर बनाया गया। यहां, function "असाइनमेंट एक्सप्रेशन" `=` के दाईं ओर बनाया गया है:

    ```js
    // Function एक्सप्रेशन
    let sum = function(a, b) {
      return a + b;
    };
    ```

अधिक सूक्ष्म अंतर यह है कि *जब* JavaScript इंजन द्वारा कोई function बनाया जाता है।

**एक function एक्सप्रेशन तब बनाया जाता है जब निष्पादन उस तक पहुँच जाता है और केवल उसी क्षण से प्रयोग करने योग्य होता है।**

एक बार निष्पादन प्रवाह असाइनमेंट के दाईं ओर जाता है `let sum = function…` -- यहां, function बनाया जाता है और अब से इसका उपयोग (असाइन, कॉल, आदि) किया जा सकता है।

Function घोषणाएं अलग हैं।

**एक function घोषणा को परिभाषित किए जाने से पहले कॉल किया जा सकता है।**

उदाहरण के लिए, एक वैश्विक function घोषणा पूरी स्क्रिप्ट में दिखाई देती है, चाहे वह कहीं भी हो।

यह आंतरिक एल्गोरिदम के कारण है। जब JavaScript स्क्रिप्ट को चलाने के लिए तैयार होता है, तो यह सबसे पहले इसमें ग्लोबल function घोषणा की तलाश करता है और function बनाता है। हम इसे "आरंभीकरण चरण" के रूप में सोच सकते हैं।

और सभी function घोषणाओं को संसाधित करने के बाद, कोड निष्पादित किया जाता है। तो इसे इन functions का एक्सेस उपलब्ध होता है।

उदाहरण के लिए, यह काम करता है:

```js run refresh untrusted
*!*
sayHi("John"); // Hello, John
*/!*

function sayHi(name) {
  alert( `Hello, ${name}` );
}
```

Function घोषणा `sayHi` तब बनाया जाता है जब JavaScript स्क्रिप्ट शुरू करने की तैयारी कर रहा होता है और इसमें हर जगह दिखाई देता है।

...यदि यह एक function एक्सप्रेशन होता, तो यह काम नहीं करता:

```js run refresh untrusted
*!*
sayHi("John"); // error!
*/!*

let sayHi = function(name) {  // (*) no magic any more
  alert( `Hello, ${name}` );
};
```

जब निष्पादन उन तक पहुंचता है तो function एक्सप्रेशन बनाए जाते हैं। यह केवल `(*)` लाइन में होगा। बहुत देर।

Function घोषणा की एक और खास विशेषता उनका ब्लॉक स्कोप है।

**सख्त मोड में, जब कोई function घोषणा कोड ब्लॉक के भीतर होती है, तो यह उस ब्लॉक के अंदर हर जगह दिखाई देती है। लेकिन इसके बाहर नहीं।**

उदाहरण के लिए, आइए कल्पना करें कि हमें रनटाइम के दौरान प्राप्त होने वाले `age` चर के आधार पर एक function `welcome()` घोषित करने की आवश्यकता है। और फिर हम इसे कुछ समय बाद उपयोग करने की योजना बनाते हैं।

यदि हम function घोषणा का उपयोग करते हैं, तो यह इरादा के अनुसार काम नहीं करेगा:

```js run
let age = prompt("What is your age?", 18);

// सशर्त रूप से एक function घोषित करें
if (age < 18) {

  function welcome() {
    alert("Hello!");
  }

} else {

  function welcome() {
    alert("Greetings!");
  }

}

// ...बाद में इसका इस्तेमाल करें
*!*
welcome(); // त्रुटि: स्वागत परिभाषित नहीं है
*/!*
```

ऐसा इसलिए है क्योंकि function घोषणा केवल उस कोड ब्लॉक के अंदर दिखाई देती है जिसमें वह रहता है।

यहाँ एक और उदाहरण है:

```js run
let age = 16; // उदाहरण के तौर पर 16 लें

if (age < 18) {
*!*
  welcome();               // \   (चल रहा है।)
*/!*
                           //  |
  function welcome() {     //  |  
    alert("Hello!");       //  |  Function घोषणा उपलब्ध है
  }                        //  |  ब्लॉक में हर जगह जहां इसे घोषित किया गया है
                           //  |
*!*
  welcome();               // /   (चल रहा है।)
*/!*

} else {

  function welcome() {    
    alert("Greetings!");
  }
}

// यहाँ हम घुंघराले ब्रेसिज़ से बाहर हैं,
// इसलिए हम उनके अंदर किए गए function घोषणा को नहीं देख सकते हैं।

*!*
welcome(); // त्रुटि: स्वागत परिभाषित नहीं है
*/!*
```

हम `if` के बाहर `welcome` को दृश्यमान बनाने के लिए क्या कर सकते हैं?

सही तरीका यह होगा कि एक function एक्सप्रेशन का उपयोग करें और `welcome` को variable में असाइन करें जिसे `if` के बाहर घोषित किया गया है और इसकी उचित दृश्यता है।

यह कोड इरादा के अनुसार काम करता है:

```js run
let age = prompt("What is your age?", 18);

let welcome;

if (age < 18) {

  welcome = function() {
    alert("Hello!");
  };

} else {

  welcome = function() {
    alert("Greetings!");
  };

}

*!*
welcome(); // अब ठीक है
*/!*
```

या हम एक प्रश्न चिह्न ऑपरेटर `?` का उपयोग करके इसे और भी सरल बना सकते हैं:

```js run
let age = prompt("What is your age?", 18);

let welcome = (age < 18) ?
  function() { alert("Hello!"); } :
  function() { alert("Greetings!"); };

*!*
welcome(); // अब ठीक है
*/!*
```


```smart header="function घोषणा बनाम function एक्सप्रेशन कब चुनें?"
एक नियम के रूप में, जब हमें किसी function को घोषित करने की आवश्यकता होती है, तो सबसे पहले विचार करने के लिए function घोषणा सिंटैक्स होता है। यह आपके कोड को व्यवस्थित करने के तरीके में अधिक स्वतंत्रता देता है, क्योंकि हम ऐसे function को घोषित होने से पहले कॉल कर सकते हैं।

यह पठनीयता के लिए भी बेहतर है, क्योंकि `let f = function(…) {…};` की तुलना में कोड में `function f(…) {…}` को देखना आसान है। Function घोषणाएं अधिक "आकर्षक" हैं।

...लेकिन अगर किसी कारण से कोई function घोषणा हमें सूट नहीं करता है, या हमें कंडीशनल घोषणा की जरूरत है (हमने अभी एक उदाहरण देखा है), तो function एक्सप्रेशन का इस्तेमाल किया जाना चाहिए।
```

## सारांश

- Functions मूल्य हैं। उन्हें कोड के किसी भी स्थान पर असाइन, कॉपी या घोषित किया जा सकता है।
- यदि function को मुख्य कोड प्रवाह में एक अलग स्टेटमेंट के रूप में घोषित किया जाता है, तो इसे "function घोषणा" कहा जाता है।
- यदि function एक एक्सप्रेशन के हिस्से के रूप में बनाया गया है, तो इसे "function एक्सप्रेशन" कहा जाता है।
- कोड ब्लॉक निष्पादित होने से पहले function घोषणाओं को संसाधित किया जाता है। वे ब्लॉक में हर जगह दिखाई दे रहे हैं।
- Function एक्सप्रेशन तब बनते हैं जब निष्पादन प्रवाह उन तक पहुंचता है।

ज्यादातर मामलों में जब हमें किसी function को घोषित करने की आवश्यकता होती है, तो function घोषणा बेहतर होती है, क्योंकि यह घोषणा से पहले ही दिखाई देती है। यह हमें कोड संगठन में अधिक लचीलापन देता है, और आमतौर पर अधिक पठनीय होता है।

इसलिए हमें function एक्सप्रेशन का उपयोग तभी करना चाहिए जब कोई function घोषणा कार्य के लिए उपयुक्त न हो। हमने इस अध्याय में इसके कुछ उदाहरण देखे हैं, और भविष्य में और देखेंगे।
